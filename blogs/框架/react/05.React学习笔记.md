---
title: React 学习笔记
date: 2021-06-05 00:00:00
sidebar: auto
sticky: false
permalink: /pages/react210605/
categories: 
  - 框架
tags: 
  - react
---
<p align="center">
  <img width="500" src="https://p15.qhimg.com/dmfd/2560_1440_/t01bc6918e95330e098.jpg"/>
</p>
>  React 基础总结

<!-- more -->

## 基础

#### 框架定义

是一个将数据渲染为HTML视图的开源 javascript 库

- react特点

  - 组件化、声明式编码，提高开发效率
  - 虚拟DOM + 优秀Diffing算法
  - 在React Native中使用React语法进行移动端开发
- 虚拟DOM

  - 本质是Object类型的对象
  - 虚拟DOM比较“轻”，真实DOM比较重
  - 虚拟DOM最终会被转化为真实DOM，呈现在页面
- jsx语法规则

  - 定义虚拟DOM时，不要写引号
  - 混入js表达式要用
  - 类名 className
  - 内联样式
  - 只有一个根标签
  - 标签必须闭合
  - 标签首字母
    - 小写（找对应html中同名元素）
    - 大写（找对应组件）

#### 准备工作

```javascript
<body>
    <script type="text/javascript" src="js/react.development.js"></script> // 引入React
    <script type="text/javascript" src="js/react-dom.development.js"></script> // 引入ReactDOM
    <script type="text/javascript" src="js/babel.min.js"></script> // 引入babel,将jsx转为js
    <script type="text/javascript" src="js/prop-types.js"></script> // 引入prop-types,用于对组件标签进行限制
</body>  
```

#### 表达式 `vs`语句

```javascript
/*
        一定注意区分：【js语句(代码)】与【js表达式】
                1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方
                            下面这些都是表达式：
                                    (1). a
                                    (2). a+b
                                    (3). demo(1)
                                    (4). arr.map()
                                    (5). function test () {}
                2.语句(代码)：
                            下面这些都是语句(代码)：
                                    (1).if(){}
                                    (2).for(){}
                                    (3).switch(){case:xxxx}

 */
```

#### 唯一key值

> 因为 `{}`要写表达式，所以要使用`arr.map`遍历

#### 创建函数式组件

```javascript
<script type="text/babel">
    function MyComponent() {
    	return <h2>自定义组件</h2>
	}
	ReactDom.reader(<MyComponent/>, document.getElementById('test'))
</script>    
```

#### 创建类式组件

```javascript
<script type="text/babel">
    class MyComponent extends React.Component {
        render() {
            return <h2>自定义组件</h2>
        }
    }
	ReactDom.render(<MyComponent/>, document.getElementById('test'))
</script>   
```

#### 组件实例核心属性State

```javascript
<script type="text/babel">
    class Weather extends React.Component {
        constructor(props) {
            super(props)
            this.state = { isHot: false, wind: '微风' }  // 第一印象，可优化
            this.changeWeather = this.changeWeather.bind(this) // 改变原型方法上this指向同时赋值给this.changeWeather方法，可优化
        }
        render() {
            const { isHot, wind } = this.state
            return <h1 onClick={this.changeWeather}>今天天气很{ isHot ? '炎热' : '凉爽' }, { wind }<h1/>
        }
        changeWeather() {
            const isHot = this.state.isHot
            this.setState({ isHot: !isHot })  // 正确写法
            // this.state.isHot = !isHot //错误写法
        }    
    }
    ReactDOM.render(<Weather/>, document.getElementById('test'))    
</script>  
```

#### 两个小技巧

```javascript
<script type="text/javascript" >
    // 类中可以直接写赋值语句，如下代码含义： 给car的实例对象添加一个属性，名为a, 值为1
    // 自定义方法——要用赋值语句的形式 + 箭头函数，故此导致this指向类
    class Car {
        constructor(name, price) {
            this.name = name
            this.price = price
            // this.wheel = 4
        }
        a = 1
        wheel = 4
        static demo = 100
    }
</script>    
```



#### state简写格式

```javascript
<script type="text/babel">
	// 创建组件
    class Weather extends React.Component {
        state = { isHot: false, wind: '微风' } // 优化一
        render() {
            const { isHot, wind } = this.state
            return <h1 onClick={ this.changeWeather }>今天天气很{isHot ? '炎热' : '凉爽'}, { wind }</h1>
        }
        // 自定义方法——要用赋值语句的形式 + 箭头函数
        changeWeather = () => { // 优化二
            const isHot = this.state.isHot
            this.setState({ isHot: !isHot })
        }
    }
	// 渲染组件到页面
	ReactDOM.render(<weather/>, document.getElementById('test'))
</script>  
```

#### props基本使用

```javascript
<script type="text/babel">
	// 创建组件
    class Person extends React.Component {
        render() {
            const { name, age, sex } = this.props
            return (
            	<ul>
                	<li>姓名：{ name }</li>
                	<li>性别：{ sex }</li>
                	<li>年龄：{ age + 1 }</li>
                </ul>
            )
        }
    }
    // 渲染组件到页面
    ReactDom.render(<Person name="jerry" age={19} sex="男"/>, document.getElementById(test1))
    ReactDom.render(<Person name="tom" age={18} sex="女"/>, document.getElementById(test2))
    const p = {name: '老刘', age: 18, sex: '女'}
    // ReactDom.render(<Person name={p.name} age={p.age} sex={p.sex}/>, document.getElementById(test3))
    ReactDom.render(<Person {...p}/>, document.getElementById('test3'))
</script>   
```

#### 展开运算符...练习

- 展开运算符不能展开对象，报错

- `{...person} `  为浅拷贝操作

- 合并修改

  ```javascript
  let person = { name: 'tom', age: 12 }
  let person2 = {...person, name: 'jack', address: '地球'}
  ```

#### props类型限制  

```javascript
<script type="text/babel">
    // 创建组件
    class Person extends React.Component{
        render() {
            const { name, age, sex } = this.props // props只读
            return (
            	<ul>
                	<li>姓名：{ name }</li>
                	<li>性别：{ sex }</li>
                	<li>年龄：{ age + 1 }</li>
                </ul>
            )
        }
    }
    Person.propTypes = {
        name: PropTypes.string.isRequired, //限制name必传，且为字符串
        sex: PropTypes,string, // 限制sex为字符串
        age: PropTypes.number, // 限制age为数值
        speak: PropTypes.func // 限制speak为函数，因为function为关键字，所以更改为func
    }
	Person.defaultProps = {
        sex: '男', // sex默认值为男
        age: 18 // age默认值为18
    }
	// 渲染组件到页面
    ReactDom.render(<Person name="jerry" age={19} sex="男"/>, document.getElementById(test1))
    ReactDom.render(<Person name="tom" age={18} sex="女"/>, document.getElementById(test2))
    const p = {name: '老刘', age: 18, sex: '女'}
    // ReactDom.render(<Person name={p.name} age={p.age} sex={p.sex}/>, document.getElementById(test3))
    ReactDom.render(<Person {...p}/>, document.getElementById('test3'))
</script>   
```

#### props简写形式

```javascript
<script type="text/babel">
    // 创建组件
    class Person extends React.Component {
        constructor(props) {
            super(props) // 构造器是否接收props,是否传递给super, 取决于： 是否希望在构造器中通过this访问props
        }
        static propTypes = {
            name: PropTypes.string.isRequired,
            sex: PropTypes.string,
            age: PropTypes.number
        }
        static defaultProps = {
            sex: '男',
            age: 18
        }
        render() {
            const { name, age, sex } = this.props // props只读
            return (
            	<ul>
                	<li>姓名：{ name }</li>
                	<li>性别：{ sex }</li>
                	<li>年龄：{ age + 1 }</li>
                </ul>
            )
        }
    }
    // 渲染組件到頁面
    ReactDOM.render(<Person name="jerry"/>, document.getElementById('test'))
</script>   
```

#### 函数式组件使用props

```javascript
<script type="text/babel">
    // 创建组件
    function Person(props) {
    	const { name, age, sex } = props
        return (
            <ul>
                <li>姓名：{ name }</li>
                <li>性别：{ sex }</li>
                <li>年龄：{ age + 1 }</li>
            </ul>
        )
	}
    Person.propTypes = {
        name: PropTypes.string.isRequired,
        sex: PropTypes.string,
        age: PropTypes.number
    }
	Person.defaultProps = {
        sex: '男'，
        age: 18
    }
	// 渲染組件到頁面
    ReactDOM.render(<Person name="jerry"/>, document.getElementById('test'))
</script>   
```

#### 字符串形式的refs

```javascript
<script type="text/babel">
    // 创建组件
    class Demo extends React.Component {
        showData = () => {
            const { input1 } = this.refs
        }
    }
	render() {
        return (
        	<input ref="input1" type="text" placeholder="点击按钮提示数据"/>
        )
    }
	// 渲染组件
	ReactDOM.render(<Demo a="1" b="2"/>, document.getElementById('test'))
</script>   
```

#### 回调函数形式的refs

```javascript
<script type="text/babel">
    // 创建组件
    class Demo extends React.Component {
        showData = () => {
            const { input1 } = this
        }
    }
	render() {
        return (
        	<input ref="{ c => this.input1 = c }" type="text" placeholder="点击按钮提示数据"/>
        )
    }
	// 渲染组件
	ReactDOM.render(<Demo a="1" b="2"/>, document.getElementById('test'))
</script>   
```

#### 回调函数refs的说明

> 如果ref回调函数是以内联函数方式定义的，在更新过程中会被执行**两次**，第一参数为null，第二次会传入参数DOM元素（当前节点）

> 解决： 通过ref的回调函数定义成calss的绑定函数的方式可以避免

> 它是无关紧要的

```javascript
<script type="text/babel">
    // 创建组件
    class Demo extends React.Component {
        showData = () => {
            const { input1 } = this
        }
    }
	// React.createRef调用后可以返回一个容器，该容器可以存储ref所标识的节点，该容器是“专人专用”
	myRef = React.createRef()
	render() {
        return (
            <div>
            	<input ref={this.myRef} type="text" placeholder="点击按钮提示数据"/>
            <div/>
        )
    }
	// 渲染组件
	ReactDOM.render(<Demo a="1" b="2"/>, document.getElementById('test'))
</script> 
```

#### 事件处理

- 通过onXxx属性指定事件处理函数（注意大小写）
  - React使用的是自定义（合成）事件，而不是使用原生DOM事件 ——为了更好的兼容性
  - React中的事件是通过事件委托方式处理的（委托组件最外层的元素）——为了高效
- 通过`event.targer`得到发生事件的DOM元素对象——不要过度使用ref

```javascript
<script type="text/babel">
    //创建组件
    class Demo extends React.Component{
        //创建ref容器
        myRef = React.createRef()
        myRef2 = React.createRef()

        //展示左侧输入框的数据，因为获取的不是本身上的属性，所有需借助ref实现
        showData = (event)=>{
            console.log(event.target);
            alert(this.myRef.current.value);
        }

        //展示右侧输入框的数据, 可以不使用ref
        showData2 = (event)=>{
            alert(event.target.value);
        }

        render(){
            return(
                <div>
                    <input ref={this.myRef} type="text" placeholder="点击按钮提示数据"/>&nbsp;
                    <button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
            		<input onBlur={this.showData2} type="text" placeholder="失去焦点提示数据"/>&nbsp;
            	</div>
			)
		}
    }
    //渲染组件到页面
    ReactDOM.render(<Demo a="1" b="2"/>,document.getElementById('test'))
</script>
```

#### 非受控组件（相当于vue中的 v-bind）

```javascript
<script type="text/babel">
	//创建组件
	class Login extends React.Component{
        render() {
            return (
            	<form onSubmit={this.handleSubmit}>
                	用户名：<input ref={ c => this.username = c } type="text" name="username"/>
                    密码：<input ref={ c => this.password = c } type="password" name="password"/>   
                <from/>
            )
        }
        handleSubmit = (event) => {
            event.preventDefault() //阻止表单提交
            const { username, password } = this
            alert(`你输入的用户名是：${username.value},你输入的密码是：${password.value}`)
        }
    }
	//渲染组件
	ReactDom.render(<login/>, document.getElementId('test'))
</script>
```

#### 受控组件

> 随着你的输入，不断维护状态（state）

> 省略ref

```javascript
<script type="text/babel">
    // 创建组件
    class Login extends React.Component{
        state = {
            username: '',
            password: ''
        }
        savePassword = (event) => {
            this.setState({username:event.target.value})
        }
        savePassword = (event) => {
            this.setState({password:event.target.value})
        }
        handleSubmit = (event) => {
            event.preventDefault()
            const {username,password} = this.state
            alert(`你输入的用户名是：${username},你输入的密码是：${password}`)
        }
        render() {
            <form onSubmit={this.handleSubmit}>
                用户名：<input onChange={this.saveUsername} type="text" name="username"/>
                密码：<input onChange={this.savePassword} type="passwod" name="password"/>
                <button>登陆</button>    
            </form>    
        }
    }
    // 渲染组件
	ReactDOM.render(<Login/>,document.getElementById('test'))
</script>
```

#### 高阶函数/柯里化

- 高阶函数（符合以下其中一个，就是高阶）

  - A函数，接受的参数是一个函数
  - A函数，返回值依然是个函数

  > Promise、setTimeout、arr.map()、arr.filter()等等

- 柯里化

  ```javascript
  // 正常写法
  function sum(a,b,c){
      return a + b + c
  }
  // 柯里化
  function sum(a) {
      return (b)=>{
          return (c)=>{
              return a+b+c
          }
      }
  }
  const result = sum(1)(2)(3)
  ```

  ![img](https://staticqn.qizuang.com/custom/20220505/Fm2P2CgbEF219tBsm863ot1iSiHH)

  ```javascript
  <script type="text/babel">
      // 创建组件
      class Login extends React.Component{
          state = {
              username: '',
              password: ''
          }
          saveFormData = (dataType) => {
              return (event)=>{
                  this.setState({[dataType]: event.target.value})
              }
          }
          //表单提交的回调
          handleSubmit = (event)=>{
              event.preventDefault() //阻止表单提交
              const {username,password} = this.state
              alert(`你输入的用户名是：${username},你输入的密码是：${password}`)
          }
          render() {
              return(
              	<form onSubmit = {this.handleSubmit}>
                  	用户名：<input onChange={this.saveFormData('username')} type="text" name="username"/>
                      密码：<input onChange={this.saveFormData('password')} type="password" name="password"/>
                      <button>登陆</button>    
                  </form>
              )
          }
      }
      // 渲染组件
  </script>    
  ```


#### 不使用柯里化

```javascript
<script type="text/babel">
	//创建组件
	class Login extends React.Component{
		//初始化状态
		state = {
			username:'', //用户名
			password:'' //密码
		}

		//保存表单数据到状态中
		saveFormData = (dataType,event)=>{
			this.setState({[dataType]:event.target.value})
		}

		//表单提交的回调
		handleSubmit = (event)=>{
			event.preventDefault() //阻止表单提交
			const {username,password} = this.state
			alert(`你输入的用户名是：${username},你输入的密码是：${password}`)
		}
		render(){
			return(
				<form onSubmit={this.handleSubmit}>
					用户名：<input onChange={event => this.saveFormData('username', event)} type="text" name="username"/>
					密码：<input onChange={event => this.saveFormData('password', event)} type="password" name="password"/>
					<button>登录</button>
				</form>
			)
		}
	}
	//渲染组件
	ReactDOM.render(<Login/>,document.getElementById('test'))
</script>
```

#### 生命周期

```javascript
<script type="text/babel">
    // 创建组件
    class Life extends React.Component {
        state = { opacity: 1 }
        death = ()=>{
            ReactDOM.ummountComponentAtNode(document.getElementById('test'))
        }
        // 组件挂载完毕
        componentDidMount() {
            this.timer = setInterval(()=>{
                let {opacity} = this.state
                opacity -= 0.1
                if(opacity <= 0) opacity = 1
                this.setState({opacity})
            },200)
        }
        componentWillUnmount(){
            clearInterval(this.timer)
        }
        render(){
            return (
            	<div>
                	<h2 style={{opacity: this.state.opacity}}>我爱范冰冰</h2>
                    <button onClick={this.death}>不活了</button>
                </div>
            )
        }
    }
    // 渲染组件
    ReactDOm.render(<Life/>, document.getElementById('test'))
</script> 
```

#### react生命周期（旧）

1. 初始化阶段

   - constructor()

   - componentWillMount()

   - render()

   - componentDidMound()    常用

     一般在这个钩子中做一些初始化的事，例如： 开启定时器，发送网络请求，订阅消息

2. 更新阶段

   > 由组件内部`this.setSate`或父组件render触发

   - shouldComponentUpdate()
   - componentWillUpdate()
   - render()
   - componentDidUpdate()

3. 卸载组件

   > 由ReactDOM.unmountComponentAtNode() 触发

   - componentWillUnmount()  常用

     一般在这个钩子做一些收尾的事，例如： 关闭定时器，取消订阅消息

#### react生命周期（新）

1. 初始化阶段

   - constructor()

   - getDerivedStateFromProps

     > 字面记忆: 即state的值在**任何时候**都取决于props
     >
     > get(获取) -   Derived(全部来源) - State - From-Props

   - render()

   - componentDidMount()

2. 更新阶段

   - getDerivedStateFromProps

   - shouldComponentUpdate()

   - render()

   - getSnapshotBeforeUpdate

     > snapshot: 快照
     >
     > 在最近一次渲染输出（提交到DOM节点）之前调用。它使得组件能在发生改变之前从DOM中捕获一些信息（例如.滚动位置）

   - componentDidUpdate()

3. 卸载组件

   - componentWillUnmount()

```javascript
// 即将废弃的钩子
1.componentWillMount
2.componentWillReceiveProps
3.componentWillUpdate
// 在新的版本中需要加上 UNSAFE_ 前缀才能使用，可能以后会废弃
// UNSAFE不是指安全性，而是表示这些生命周期的代码在React 的未来版本中更有可能出现bug，尤其在开启异步渲染后
```

#### key的作用

1. key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用

2. 详细的说: 当状态中数据发生变化时，react会根据 新数据 生成 新的虚拟DOM

   ​                  随后React 进行 新虚拟DOM 与 旧虚拟DOM diff比较，比较规则如下

   - 旧虚拟DOM中找到了与新虚拟DOM相同的key
     - 若虚拟DOM中内容没变，直接使用之前的真实的DOM
     - 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换页面中之前真实DOM
   - 旧虚拟DOM中未找到与新虚拟DOM相同的key
     - 根据数据创建新的真实DOM，随后渲染到页面

#### 用index可能引发的问题

1. 对数据进行： 逆序添加，逆序删除等破坏操作

   > 会产生没有必要的真实DOM更新  ==》 界面效果没问题，但效率低

2. 如果结构中还包含输入类的DOM

   > 会产生错误的DOM更新 ==》 界面有问题

3. 注意，如果只是用来展示操作，用`index`作为key值是没有问题的



## 扩展

#### src文件夹介绍

- public

  ```javascript
  index.html // 主页面
  manifest.json // 应用加壳文件
  robots.txt // 爬虫协议文件
  ```

- src

  ```javascript
  App.js // App组件
  index.js // 入口文件
  App.text.js // 用于给App做测试
  reprotWebVitals.js // 页面性能分析文件（需web-vitals库的支持）
  setupTests.js // 组件单元测试的文件（需要jest-dom库的支持）
  ```


#### 配置代理方式

1. 方法一

   > 在package.json中追加如下配置

   ```json
   {
       "proxy": "http://loclhost:5000"
   }
   ```

   > 说明

   - 优点： 配置简单，前端请求资源可以不加任何前缀
   - 缺点： 不能配置多个代理
   - 工作方式： 上诉方式配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000（优先匹配前端资源）

2. 方法二

   - 创建代理文件

     在src下创建配置文件： `src/setupProxy.js`

   - 编写setupProxy.js配置具体代理规则

     ```javascript
     const proxy = require('http-proxy-middleware')
     
     module.exports = function(app) {
         app.use(
         	proxy('/api1',{ //api1是需要转发的请求（所有）
                 target: 'http://localhost: 5000', // 配置转发目标地址
                 changeOrigin: true, //控制服务器接收到的请求头中host字段的值
                 /*
              	changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
              	changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000
              	changeOrigin默认值为false，但我们一般将changeOrigin值设为true
              	*/
                 pathRewrite: {'^/api1': ''} // 去除请求前缀，保证交给后台服务器的是正常请求地址（必须配置）
             })，
             proxy('/api2',{
             	target: 'http://localhost:5001',
             	changeOrigin: true,
             	pathRewrite: {'^/api2': ''}
             })
         )
     }
     ```

   > 说明

   - 优点： 可以配置多个代理，可以灵活的控制请求是否走代理
   - 缺点： 配置繁琐，前端请求资源时必须加前缀

#### 消息订阅发布

- 工具库：PubSubJS

- 下载：npm install pubsub-js --save

- 使用

  ```javascript
  import PubSub from 'pubsub-js' // 引入
  this.token = PubSub.subscribe('delete',function(data){}) // 订阅
  PubSub.publish('delete',data) // 发布消息
  
  componentWillUnmount() {
      PubSub.unsubscribe(this.token) // 取消订阅
  }
  ```

#### Fetch

- **概念**

  - 关注分离

    `XMLHttpRequest`配置与调用方式混乱

  - 异步模型

    `Promise`     `generator/yield`   `async/awiat`

- **API**

  - get请求

    ```javascript
    fetch(url).then(function(response){
        return response.json()
    }).then(function(data){
        console.log(data)
    }).catch(function(e){
        console.log(e)
    })
    ```

  - post请求

    ```javascript
    fetch(url, {
        method: 'post',
        body:JSON.stringify(data)
    }).then(function(data){
        console.log(data)
    }).catch(function(e){
        console.log(e)
    })
    ```

  - fetch发送（优化）

    ```javascript
    try{
    	const response = await fetch(url)
    	const data = await response.json()
    } catch (error){
    	console.log('请求出错', error)
    }
    ```

## React路由

#### SPA的理解

- 单页Web应用（single page web application, SPA）
- 整个应用只有一个完整的页面
- 点击页面中的链接不会刷新页面，只会做页面的局部更新
- 数据都需要通过ajax请求获取，并在前端异步展现

#### react-router-dom的理解

- react的一个插件库
- 专门用来实现一个SPA应用
- 基于react的项目基本都会用到此库

#### react-route-dom相关API

- 内置组件

  1. `<BrowserRouter>`

  2. `<HashRouter>`

  3. `<Route>`

  4. `<Redirect>`

  5. `<Link>`

  6. `<NavLink>`

     路由点击的高亮，通过activeClassName指定样式

  7. `<Switch>`

- 路由的基本使用

  > 基本界面

  ```javascript
  // 编写路由链接  
  <Link className="list-group-item" to="/about">About</Link>
  <Link className="list-group-item" to="/home">Home</Link>
  
  // 注册路由
  <Route path="/about" component={About}/>
  <Route path="/home" component={Home}/>
  ```
  
  > 主页面
  
  ```javascript
  ReactDOM.render(
  	<BrowserRouter>
      	<APP/>
      </BrowserRouter>,
      document.getElementById('root')
  )
  ```
  
- 路由组件和普通组件区别

  - 写法不同

    一般组件： `<Demo/>`

    路由组件：`<Route path="/demo"  component={Demo}/>`

  - 存放位置不同

    一般组件：`components`

    路由组件：`pages`

  - 接收到的props不同

    一般组件：写组件标签时传递了什么，就能收到什么

    路由组件： 接收到三个固定的属性

    ```javascript
    history:
            go: f go(n)
            goBack: f goBack()
            goForward: f goForward()
            push: f push(path, state)
            replace: f replace(path, state)
    location: 
            pathname: "/about"
            search: ""
            state: undefined
    match:
            params: {}
            path: "/about"
            url: "/about"
    ```

#### 标签体内容children

- 通过this.porps.children 可以获取标签体内容

#### 解决路由刷新样式丢失问题

- public/index.html 中引入样式时，不写 `./`, 写 `/`  常用
- public/index.html 中引入样式时，不写`./`, 写`%PUBLIC_URL%`
- 使用`HashRouter`

## 参考

- [React 中文文档](https://zh-hans.reactjs.org/docs/getting-started.html)
- [Redux 中文文档](http://cn.redux.js.org/)
- [React Router 官网](https://reactrouter.com/web/guides/quick-start) 英文版
- [React 高阶组件(HOC)的入门 📖 及实践 💻](https://juejin.cn/post/6844904050236850184)
- [react-redux 的简单使用](https://zhuanlan.zhihu.com/p/62417038)
- [react 路由传参及其区别](https://segmentfault.com/a/1190000023554534)
- [学习笔记1](https://docs.qq.com/doc/DSG1jdUJtQ3FYR1V1)
- [学习笔记2](https://docs.qq.com/doc/DSGhGZk9PUm1KVldv)
