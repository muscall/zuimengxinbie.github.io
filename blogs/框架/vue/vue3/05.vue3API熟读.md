---
title: vue3API熟读
date: 2022-04-21 00:00:00
sidebar: auto
sticky: false
permalink: /pages/vue220421/
categories: 
  - 框架
tags: 
  - vue

---

<p align="center">
  <img width="500" src="https://p18.qhimg.com/dmfd/2560_1440_/t01b2e930c2f1bcb2b9.jpg"/>
</p>



> 待完善，感谢指教💕
> <!-- more -->

## vue3API熟读

### 全局API

- createSSRAPP

  > 以SSR激活模创建一个应用实例。 用法与createApp（） 相同
  >
  > `ssr` 框架是为前端框架在服务端渲染的场景下所打造的开箱即用的服务端渲染框架

- app.provide()

  > 提供一个值，可以在应用中所有后代组件注入使用

  ```vue
  import { createApp } from 'vue'
  const app = createApp(/*...*/)
  app.provide('message', 'hello')
  
  // 某个组件中
  export default {
  	inject: ['message'],
  	created() {
  		console.log(this.message) // 'hello'
  	}
  }
  ```

- app.mixin

  > Vue3 不推荐， 采用组合式函数来替代

- app.version

  > 针对不同的vue版本，做出不同的处理， 插件中比较多用

- app.config

  > 每个应用实例都会暴露一个confing 对象，其中包含了对这个应用的配置设定，可以再挂载应用前更改这些属性

  - app.config.errorHandler

    - 来源
      1. 组件渲染器
      2. 事件处理器
      3. 声明周期钩子
      4. setup（）函数
      5. 侦听器
      6. 自定义指令钩子
      7. 过渡钩子

    ```
    app.config.errorHandler = (err, instance, info) => {
    	// 处理错误，例如： 报告给一个服务
    }
    ```

  - app.config.warnHandler

    > 警告，只存在开发环境

  - app.config.performance

    > 类型： bool
    >
    > 是否支持带有 `Performance insights`（性能洞察） 的浏览器

  - app.config.compilerOptions

    > 配置编译选项

    [compilerOptions](https://staging-cn.vuejs.org/api/application.html#app-config-compileroptions)

  - **app.config.globalProperties**

    > 原型更改

  - app.config.optionMergeStrategies

    > 自定义合并策略（比如之前的mixins）

- nextTick()

  > [nextTick](https://staging-cn.vuejs.org/api/general.html#nexttick)

- [defineComponent()](https://staging-cn.vuejs.org/api/general.html#definecomponent)

- [defineAsyncComponent()](https://staging-cn.vuejs.org/api/general.html#defineasynccomponent)

- [defineCustomElement()](https://staging-cn.vuejs.org/api/general.html#definecustomelement)

### 内置内容

- v-memo

  - 场景

    用于**性能至上**场景中的微小优化，有助于渲染海量 `v-for` 列表 （当 length > 1000）

  - 演示

    ```
    <div v-for="item in list" :key="item.id" v-memo="[item.id === selected]">
      <p>ID: {{ item.id }} - selected: {{ item.id === selected }}</p>
      <p>...more child nodes</p>
    </div
    ```

    当组件的 `selected` 状态改变，大量的 vnode 将会被创建，尽管大部分项都是完全一致。`v-memo` 用在这里本质上是在说“只有从未选中变为选中或者相反转变时才更新”。这使得每个未受影响的项能重用之前的 vnode 并完全跳过差异比较。注意这里我们并不需要包含 `item.id` 在 memo 依赖数组中，因为 Vue 会根据 item 的 `:key` 进行推断。

  
