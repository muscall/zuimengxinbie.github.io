---
title: 日常回顾【TypeScript】
date: 2022-01-13 00:00:00
sidebar: auto
sticky: false
permalink: /pages/ts220113/
categories: 
  - 技术
tags: 
  - ts
---
<p align="center">
  <img width="500" src="https://p15.qhimg.com/dmfd/2560_1440_/t0178615cd271ee0846.jpg"/>
</p>


> 边学边写，冲冲冲

<!-- more -->

- 声明

  - interface

    ```javascript
    interface Hero {
        name: string;
        age: number;
    }
    ```

  - type

    ```javascript
    type Hero = {
        name: string;
        age: number;
    }
    ```

    > 区别

    - type更为强大
    - type需 “ = ” 来接收
    - interface 可以进行声明合并，type不行
    - interface仅限于描述对象类型
    - [详细](https://mp.weixin.qq.com/s/Y96lcMspyQ5WvXfoI61USg)

- any 与 unkown

  - 所有类型都可以分配给 any， 同样所有类型也都可以分配给 unknown

  - 执行操作

    - any类型的值可以执行任何操作，免检标签； 解决TypeScript 中类型问题的最后一个手段。
    - unknow在没有进行类型检查之前，不能进行任何操作，重点检查标签

  - 标签

    - any ：免检标签
    - unknow ： 重点检查标签

  - 什么时候可以使用 unknown

    - 类型断言

      ```
      const number: unknown = 15;
      (number as string).toLowerCase();
      ```

    - 类型收缩

      > 配合if语句使用

      > ​	`typeof`     `instance` : 检查属性是否存在实例的原型链上

- 联合类型 / 交叉类型

  - |

    可以接受不同的类型参数

  - &  **优先级高**

    **合并接口类型**

    ```
    type IntersectionType = { id: number; name: string } & { age: number }
    const arr:IntersectionType = {
    	id: 1,
    	name: 'name',
    	age: 18
    }
    ```

    - 问题一

      > name属性的类型就是 number 和 string 两个类型的交叉类型， 即never

      ```
      type IntersectionTypeConfict = { id: number; name: string } & { age: number; name: number };
      
      const arr: IntersectionTypeConfict = {
      	id: 1,
      	name: 2,  // ts报错，‘number’ 类型不能赋值给 ‘never’ 类型
      	age: 3
      }
      ```

      > 解决

      ```
      type IntersectionTypeConfict = { id: number; name: 2 } & { age: number; name: number };
      
      const arr: IntersectionTypeConfict = {
      	id: 1,
      	name: 2,  // ok
      	age: 3
      }
      
      const arr1: IntersectionTypeConfict = {
      	id: 1, 
      	name: 22, // '22'类型不能赋值给 '2' 类型
      	age: 3
      }
      ```

    **合并联合类型**

    - 问题一

      ```
      type UnionA = 'px' | 'em' | 'rem' | '%'
      type UnionB = 'vh' | 'em' | 'rem' | 'pt'
      
      type arr = UnionA & UnionB
      
      const obj1: arr = 'em'
      const obj2: arr = 'rem'
      const obj3: arr = 'px'  // 类型 ‘px’ 不能赋值给 'em' | 'rem'
      const obj4: arr = 'pt'  // 类型 ‘pt’ 不能赋值给 'em' | 'rem'
      ```

    - 问题二

      ```
      type UnionC = 'em' | 'rem'
      type UnionD = 'px' | 'pt'
      type Intersection = UnionC & UnionD
      ```

      > 上诉 案例中，因为UnionC 和 UnionD 没有交集， 交叉出来的类型 是 **never** 类型

- 断言

  主要通过 `as` 语法， 告诉ts这个变量属于哪个类型，一般用在你比 TypeScript 更了解某个值的详细信息

- **类型推断(推论)**

  ```
  // ts可以 count 为 number 类型
  let count = 123;
  ```

- 函数的类型

  - 函数声明

    ```
    function sum(x, y) {
    	return x+y
    }
    ```

    > ts 表示

    ```
    function sum(x: number, y: number): number{
    	return x + y
    }
    ```

    

  - 函数表达式

    ```javascript
    let mySum = function(x, y) {
    	return x + y;
    }
    ```

    > ts 表示

    ```
    let mySum: (x: number, y: number) => number = function(x: number, y: number): number {
    	return x+y
    }
    ```

    **注意不要混淆了 TypeScript 中的 => 和 ES6 中的 =>**

    - TypeScript的类型定义中， => 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型
    - ES6中， => 叫做箭头函数

  - 重载

    允许一个函数接受不同数量或类型的参数时，作出不同的处理

    - 案例

      实现一个函数 reverse, 输入数字 `123` 的时候，输出反转的数字 `321`, 输入字符串 `hello`的时候， 输出反转的字符串 `olleh`

      ```js
      function reverse(x: number | string): number | string | void {
      	if(typeof x === 'number') {
      		return Number(x.toString().split('').reverse().join(''))
      	} else if(typeof x === 'string') {
      		return x.split('').reverse().join('')
      	}
      }
      ```

    - 问题

      不够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。

    - 解决

      > 多次 **函数定义**
      >
      > 最后一次 **函数实现**  ， 加 `{}`

      ```js
      function reverse(x: number): number;
      function reverse(x: string): string;
      function reverse(x: number | string): number | string | void {
          if(typeof x === 'number') {
      		return Number(x.toString().split('').reverse().join(''))
      	} else if(typeof x === 'string') {
      		return x.split('').reverse().join('')
      	}
      }
      ```

      

- 数组的类型

  - [类型 + 方括号] 表示法

    ```
    let arr: number[] = [1,2,3,4,5]
    ```

  - 数组泛型

    ```
    let arr: Array<number> = [1,2,3,4,5]
    ```

  - 接口表示数组

    ```
    interface NumberArray {
    	[index: number]: number;
    }
    let arr: NumberArray = [1,2,3,4,5]
    ```

  - 类数组

    - 常见的类数组

      函数的参数`arguments` 、 DOM列表对象、  jQuery对象

    - 表现

      有length属性
